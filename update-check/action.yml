name: 'Update README Version/Hash'
description: 'Check upstream repo for updates and update commit hash or version in README.org'
author: 'Anthony Green'

inputs:
  upstream-repo:
    description: 'Upstream repository URL (optional - will be extracted from README source line if not provided)'
    required: false
    default: ''
  readme-path:
    description: 'Path to README file'
    required: false
    default: 'README.org'
  github-token:
    description: 'GitHub token for creating issues (automatically uses github.token if not provided)'
    required: false
    default: ''

outputs:
  updated:
    description: 'Whether an update was detected and applied (true/false)'
    value: ${{ steps.check.outputs.updated }}

runs:
  using: 'composite'
  steps:
    - name: Check and update
      id: check
      shell: bash
      run: |
        set -x  # Enable debug tracing
        README="${{ inputs.readme-path }}"
        UPSTREAM="${{ inputs.upstream-repo }}"
        INPUT_TOKEN="${{ inputs.github-token }}"

        # Use input token if provided, otherwise fall back to GITHUB_TOKEN env var
        if [ -n "$INPUT_TOKEN" ]; then
          GITHUB_TOKEN="$INPUT_TOKEN"
        fi
        # GITHUB_TOKEN env var is already set by GitHub Actions if available

        # Default to no update
        echo "updated=false" >> $GITHUB_OUTPUT

        # Function to retry commands with exponential backoff
        retry_with_backoff() {
          local max_attempts=5
          local timeout=1
          local attempt=1
          local exit_code=0

          while [ $attempt -le $max_attempts ]; do
            if [ $attempt -gt 1 ]; then
              echo "Retry attempt $attempt of $max_attempts (waiting ${timeout}s)..."
              sleep $timeout
            fi

            # Execute the command
            "$@"
            exit_code=$?

            if [ $exit_code -eq 0 ]; then
              return 0
            fi

            # Double the timeout for next attempt (exponential backoff)
            timeout=$((timeout * 2))
            attempt=$((attempt + 1))
          done

          echo "Command failed after $max_attempts attempts"
          return $exit_code
        }

        # Function to create issue for missing repo
        create_missing_repo_issue() {
          local repo_url="$1"
          local package_name="$2"

          if [ -z "$GITHUB_TOKEN" ]; then
            echo "Warning: Cannot create issue - GITHUB_TOKEN not provided"
            return 0
          fi

          # Extract package/project name from README or path
          if [ -z "$package_name" ]; then
            package_name=$(grep '^| name  *|' "$README" | awk '{print $4}' | head -1 || true)
          fi

          if [ -z "$package_name" ]; then
            package_name=$(basename $(pwd))
          fi

          # Get current repository from GITHUB_REPOSITORY env var or git remote
          local current_repo="$GITHUB_REPOSITORY"
          if [ -z "$current_repo" ]; then
            current_repo=$(git remote get-url origin | sed 's|.*github.com[:/]||' | sed 's|\.git$||')
          fi

          if [ -z "$current_repo" ]; then
            echo "Warning: Cannot determine current repository"
            return 0
          fi

          local issue_title="Missing upstream repository: $package_name"
          local issue_body
          issue_body=$(printf "The upstream repository for %s appears to be missing or inaccessible.\n\nRepository URL: %s\n\nThe repository may have been:\n- Deleted or moved\n- Made private\n- Renamed without a redirect\n\nPlease investigate and either:\n1. Update the source URL in the README if the repository moved\n2. Find an alternative source\n3. Archive this package if no longer maintained" "$package_name" "$repo_url")

          # Check if issue already exists
          echo "Checking for existing issues about missing repo..."
          local existing_issues=$(curl -s \
            -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/$current_repo/issues?state=open" \
            | grep -c "\"title\": \"$issue_title\"" || true)

          if [ "$existing_issues" -gt 0 ]; then
            echo "Issue already exists for missing repo: $repo_url"
            return 0
          fi

          # Create the issue
          echo "Creating issue for missing repo: $repo_url"
          local response=$(curl -s -w "\n%{http_code}" \
            -X POST \
            -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/$current_repo/issues" \
            -d "{\"title\":\"$issue_title\",\"body\":$(echo "$issue_body" | jq -Rs .)}")

          local http_code=$(echo "$response" | tail -1)

          if [ "$http_code" = "201" ]; then
            echo "Successfully created issue for missing repo"
            return 0
          else
            echo "Failed to create issue (HTTP $http_code)"
            echo "$response" | head -n -1
            return 0
          fi
        }

        # If upstream not provided, extract from README source or file line
        if [ -z "$UPSTREAM" ]; then
          SOURCE_URL=$(grep -E '^\| (source|file)  *\|' "$README" | awk '{print $4}' | sed 's/^git://' | sed 's/^file://')

          # Extract repo URL from tarball/archive URLs
          if echo "$SOURCE_URL" | grep -q '/archive/'; then
            # GitHub archive URL: extract repo path
            UPSTREAM=$(echo "$SOURCE_URL" | sed 's|/archive/.*||')
          elif echo "$SOURCE_URL" | grep -q '\.tar\.gz$\|\.tgz$\|\.zip$'; then
            # Generic tarball - try to extract repo URL
            UPSTREAM=$(echo "$SOURCE_URL" | sed 's|/releases/.*||' | sed 's|/archive/.*||')
          else
            # Assume it's already a repo URL
            UPSTREAM="$SOURCE_URL"
          fi

          echo "Extracted upstream from README: $UPSTREAM"
        fi

        # Check if upstream is GitHub, SourceHut, or Codeberg
        if ! echo "$UPSTREAM" | grep -qE '(github\.com|git\.sr\.ht|codeberg\.org)'; then
          echo "Skipping: Only GitHub, SourceHut, and Codeberg are supported"
          echo "Upstream: $UPSTREAM"
          exit 0
        fi

        # Skip mfiano repos (github.com/mfiano has disappeared)
        if echo "$UPSTREAM" | grep -q 'github\.com/mfiano'; then
          echo "Skipping: mfiano repos are handled separately"
          exit 0
        fi

        # Determine if this is git-based or version-based
        if grep -q '^| commit  |' "$README"; then
          # Git commit mode
          echo "Mode: Git commit tracking"

          CURRENT_HASH=$(grep '^| commit  |' "$README" | awk '{print $4}')
          echo "Current hash: $CURRENT_HASH"

          # Fetch latest commit from upstream repo with retry
          TEMP_OUTPUT=$(mktemp)
          if retry_with_backoff bash -c "git ls-remote '$UPSTREAM' HEAD 2>&1 | head -1 > '$TEMP_OUTPUT'"; then
            LATEST_HASH=$(cat "$TEMP_OUTPUT" | cut -f1 | cut -c1-7)
            rm -f "$TEMP_OUTPUT"
          else
            rm -f "$TEMP_OUTPUT"
            LATEST_HASH=""
          fi

          # Check if git ls-remote failed (repo missing/inaccessible)
          # Valid hash should be 7 hexadecimal characters
          if [ -z "$LATEST_HASH" ] || ! echo "$LATEST_HASH" | grep -qE '^[0-9a-f]{7}$'; then
            echo "Warning: Unable to access repository after retries: $UPSTREAM"
            create_missing_repo_issue "$UPSTREAM" ""
            exit 0
          fi

          echo "Latest hash: $LATEST_HASH"

          if [ "$CURRENT_HASH" != "$LATEST_HASH" ]; then
            echo "Update detected: $CURRENT_HASH -> $LATEST_HASH"

            # Update the hash in README (handle both 7 and 8 character hashes, with or without trailing |)
            sed -i "s/^| commit  | [a-f0-9]\{7,8\}\( *|\?\)/| commit  | $LATEST_HASH\1/" "$README"

            # Commit and push
            git config --local user.email "github-actions[bot]@users.noreply.github.com"
            git config --local user.name "github-actions[bot]"
            git add "$README"
            git commit -m "Update commit hash to $LATEST_HASH"
            git push

            echo "updated=true" >> $GITHUB_OUTPUT
            echo "Updated and pushed changes"
          else
            echo "No update needed"
          fi

        elif grep -q '^| version |' "$README"; then
          # Version/release mode
          echo "Mode: Version/release tracking"

          CURRENT_VERSION=$(grep '^| version |' "$README" | awk '{print $4}')
          echo "Current version: $CURRENT_VERSION"

          if echo "$UPSTREAM" | grep -q 'github\.com'; then
            # GitHub releases
            REPO=$(echo "$UPSTREAM" | sed 's|.*github.com/||' | sed 's|\.git$||')
            echo "GitHub repo: $REPO"

            # Fetch latest release tag with retry
            TEMP_OUTPUT=$(mktemp)
            if retry_with_backoff bash -c "curl -s -w '\n%{http_code}' 'https://api.github.com/repos/$REPO/releases/latest' > '$TEMP_OUTPUT'"; then
              API_RESPONSE=$(cat "$TEMP_OUTPUT")
              rm -f "$TEMP_OUTPUT"
            else
              API_RESPONSE=$(cat "$TEMP_OUTPUT")
              rm -f "$TEMP_OUTPUT"
            fi
            HTTP_CODE=$(echo "$API_RESPONSE" | tail -1)
            API_BODY=$(echo "$API_RESPONSE" | sed '$d')

            # Extract version from release (404 just means no releases, not missing repo)
            LATEST_VERSION=$(echo "$API_BODY" | grep '"tag_name"' | sed -E 's/.*"([^"]+)".*/\1/' | sed 's/^release-//' | sed 's/^v//' || true)

            # If no releases, try tags
            if [ -z "$LATEST_VERSION" ]; then
              echo "No releases found, checking tags..."
              TEMP_OUTPUT=$(mktemp)
              if retry_with_backoff bash -c "git ls-remote --tags '$UPSTREAM' 2>&1 > '$TEMP_OUTPUT'"; then
                TAG_OUTPUT=$(cat "$TEMP_OUTPUT")
                rm -f "$TEMP_OUTPUT"
              else
                TAG_OUTPUT=$(cat "$TEMP_OUTPUT")
                rm -f "$TEMP_OUTPUT"
              fi

              # Check if git ls-remote failed
              if echo "$TAG_OUTPUT" | grep -qE '(fatal|error|Repository not found|Could not read)'; then
                echo "Warning: Unable to access repository after retries: $UPSTREAM"
                create_missing_repo_issue "$UPSTREAM" ""
                exit 0
              fi

              LATEST_VERSION=$(echo "$TAG_OUTPUT" | grep -v '\^{}' | tail -1 | sed 's|.*/||' | sed 's/^release-//' | sed 's/^v//')
            fi

          elif echo "$UPSTREAM" | grep -q 'codeberg\.org'; then
            # Codeberg releases (uses Forgejo API)
            REPO=$(echo "$UPSTREAM" | sed 's|.*codeberg.org/||' | sed 's|\.git$||')
            echo "Codeberg repo: $REPO"

            # Fetch latest release tag using Forgejo API with retry
            TEMP_OUTPUT=$(mktemp)
            if retry_with_backoff bash -c "curl -s -w '\n%{http_code}' 'https://codeberg.org/api/v1/repos/$REPO/releases/latest' > '$TEMP_OUTPUT'"; then
              API_RESPONSE=$(cat "$TEMP_OUTPUT")
              rm -f "$TEMP_OUTPUT"
            else
              API_RESPONSE=$(cat "$TEMP_OUTPUT")
              rm -f "$TEMP_OUTPUT"
            fi
            HTTP_CODE=$(echo "$API_RESPONSE" | tail -1)
            API_BODY=$(echo "$API_RESPONSE" | sed '$d')

            # Extract version from release (404 just means no releases, not missing repo)
            LATEST_VERSION=$(echo "$API_BODY" | grep '"tag_name"' | sed -E 's/.*"([^"]+)".*/\1/' | sed 's/^release-//' | sed 's/^v//' || true)

            # If no releases, try tags
            if [ -z "$LATEST_VERSION" ]; then
              echo "No releases found, checking tags..."
              TEMP_OUTPUT=$(mktemp)
              if retry_with_backoff bash -c "git ls-remote --tags '$UPSTREAM' 2>&1 > '$TEMP_OUTPUT'"; then
                TAG_OUTPUT=$(cat "$TEMP_OUTPUT")
                rm -f "$TEMP_OUTPUT"
              else
                TAG_OUTPUT=$(cat "$TEMP_OUTPUT")
                rm -f "$TEMP_OUTPUT"
              fi

              # Check if git ls-remote failed
              if echo "$TAG_OUTPUT" | grep -qE '(fatal|error|Repository not found|Could not read)'; then
                echo "Warning: Unable to access repository after retries: $UPSTREAM"
                create_missing_repo_issue "$UPSTREAM" ""
                exit 0
              fi

              LATEST_VERSION=$(echo "$TAG_OUTPUT" | grep -v '\^{}' | tail -1 | sed 's|.*/||' | sed 's/^release-//' | sed 's/^v//')
            fi

          elif echo "$UPSTREAM" | grep -q 'git\.sr\.ht'; then
            # SourceHut tags
            echo "SourceHut repo: $UPSTREAM"

            # Fetch latest tag with retry
            TEMP_OUTPUT=$(mktemp)
            if retry_with_backoff bash -c "git ls-remote --tags '$UPSTREAM' 2>&1 > '$TEMP_OUTPUT'"; then
              TAG_OUTPUT=$(cat "$TEMP_OUTPUT")
              rm -f "$TEMP_OUTPUT"
            else
              TAG_OUTPUT=$(cat "$TEMP_OUTPUT")
              rm -f "$TEMP_OUTPUT"
            fi

            # Check if git ls-remote failed
            if echo "$TAG_OUTPUT" | grep -qE '(fatal|error|Repository not found|Could not read)'; then
              echo "Warning: Unable to access repository after retries: $UPSTREAM"
              create_missing_repo_issue "$UPSTREAM" ""
              exit 0
            fi

            LATEST_VERSION=$(echo "$TAG_OUTPUT" | grep -v '\^{}' | tail -1 | sed 's|.*/||' | sed 's/^release-//' | sed 's/^v//')
          fi

          echo "Latest version: $LATEST_VERSION"

          if [ -n "$LATEST_VERSION" ] && [ "$CURRENT_VERSION" != "$LATEST_VERSION" ]; then
            echo "Update detected: $CURRENT_VERSION -> $LATEST_VERSION"

            # Update version in README
            sed -i "s/^| version | [^ ]*\( *\)|/| version | $LATEST_VERSION\1|/" "$README"

            # Update source URL if it contains the version (handle various patterns)
            sed -i "s|release-${CURRENT_VERSION}|release-${LATEST_VERSION}|g" "$README"
            sed -i "s|/v${CURRENT_VERSION}|/v${LATEST_VERSION}|g" "$README"
            sed -i "s|/${CURRENT_VERSION}\.tar|/${LATEST_VERSION}.tar|g" "$README"

            # Commit and push
            git config --local user.email "github-actions[bot]@users.noreply.github.com"
            git config --local user.name "github-actions[bot]"
            git add "$README"
            git commit -m "Update version to $LATEST_VERSION"
            git push

            echo "updated=true" >> $GITHUB_OUTPUT
            echo "Updated and pushed changes"
          else
            echo "No update needed"
          fi

        else
          echo "Error: README does not contain '| commit' or '| version' line"
          exit 1
        fi

branding:
  icon: 'refresh-cw'
  color: 'blue'
